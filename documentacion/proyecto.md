# üì± Proyecto: App de Tracking de Ubicaci√≥n

## üìã √çndice

1. [Resumen Ejecutivo](#resumen-ejecutivo)
2. [Stack Tecnol√≥gico](#stack-tecnol√≥gico)
3. [Arquitectura](#arquitectura)
4. [Caracter√≠sticas T√©cnicas](#caracter√≠sticas-t√©cnicas)
5. [Base de Datos](#base-de-datos)
6. [Plan de Desarrollo](#plan-de-desarrollo)
7. [Gu√≠a de Setup](#gu√≠a-de-setup)
8. [C√≥digo de Referencia](#c√≥digo-de-referencia)
9. [Infraestructura](#infraestructura)
10. [Roadmap](#roadmap)

---

## üéØ Resumen Ejecutivo

### Objetivo
Crear una aplicaci√≥n m√≥vil Android que capture la ubicaci√≥n del usuario cada 5 minutos de forma no intrusiva, almacene el historial en una base de datos geoespacial, y permita visualizar por d√≥nde estuvo en el tiempo. El soporte iOS queda planificado para una fase posterior junto con el an√°lisis de rutas √≥ptimas.

### Equipo
- **2 desarrolladores**
- **1 servidor propio**
- **Tiempo PoC:** 3 semanas

### Alcance MVP
- ‚úÖ Tracking autom√°tico cada 5 minutos
- ‚úÖ Visualizaci√≥n de rutas en mapa
- ‚úÖ Historial por fechas
- ‚úÖ Estad√≠sticas b√°sicas (distancia recorrida)
- ‚úÖ Optimizaci√≥n de bater√≠a
- ‚úÖ Login/Autenticaci√≥n
- ‚úÖ Distribuci√≥n Android (Play Store/Test interno)

---

## üõ†Ô∏è Stack Tecnol√≥gico

### Frontend (Mobile)
```yaml
Plataforma: Flutter + Dart (MVP Android)
Motivo: C√≥digo compartido Android/iOS sin duplicar c√≥digo; el MVP se enfoca en Android y deja preparado el port para la fase iOS.
Librer√≠as principales:
  - geolocator: ^11.0.0           # Captura GPS
  - flutter_map: ^6.1.0            # Mapas OpenStreetMap
  - firebase_auth: ^4.15.3         # Autenticaci√≥n
  - flutter_foreground_task: ^6.1.1 # Servicio background
  - battery_plus: ^5.0.2           # Monitoreo bater√≠a
  - http: ^1.1.2                   # API calls
```

### Backend
```yaml
Framework: Spring Boot 3.5.6 (Java 21)
Motivo: Ecosistema maduro, Hibernate Spatial estable
Dependencias:
  - Spring Web                     # REST API
  - Spring Data JPA                # ORM
  - PostgreSQL Driver              # Conexi√≥n DB
  - Hibernate Spatial              # PostGIS support
  - Lombok                         # Reducci√≥n de boilerplate
  - Spring Boot Validation         # Validaciones @Valid
  - Firebase Admin SDK 9.2.0       # Auth validation
  - Spring Security                # Seguridad
  - Springdoc OpenAPI              # Documentaci√≥n Swagger
```

### Base de Datos
```yaml
Motor: PostgreSQL 16
Extensi√≥n: PostGIS 3.4
Motivo: Mejor opci√≥n para an√°lisis geoespaciales y rutas √≥ptimas
Caracter√≠sticas:
  - Queries geoespaciales nativas
  - C√°lculo de distancias reales
  - √çndices espaciales (GIST)
  - Soporte para algoritmos de rutas
```

### Autenticaci√≥n
```yaml
Servicio: Firebase Authentication
Plan: Free tier (hasta 50,000 usuarios)
M√©todos: Email/Password
```

### Mapas y Rutas
```yaml
Visualizaci√≥n: 
  - OpenStreetMap (gratis)
  - flutter_map plugin
  
Rutas √≥ptimas (Fase 2):
  - OSRM (Open Source Routing Machine)
  - Self-hosted en Docker
```

---

## üìê Arquitectura

### Diagrama de Componentes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Flutter Mobile App              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ UI Layer ‚îÇ  ‚îÇ Services ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ  Screens ‚îÇ  ‚îÇ Location ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ   Maps   ‚îÇ  ‚îÇ   API    ‚îÇ            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ           ‚îÇ
    (GPS) ‚îÇ           ‚îÇ (HTTPS/REST)
          ‚îÇ           ‚îÇ
          ‚ñº           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Firebase Authentication            ‚îÇ
‚îÇ         (Token Validation)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚îÇ (JWT Token)
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Spring Boot REST API               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Controllers (REST Endpoints)     ‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ
‚îÇ  ‚îÇ Services (Business Logic)        ‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ
‚îÇ  ‚îÇ Repositories (Data Access)       ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
              ‚îÇ (JDBC)
              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    PostgreSQL + PostGIS Database        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Table: users                     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Table: locations (GEOGRAPHY)     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Spatial Indexes (GIST)           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Geospatial Queries               ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
              ‚îÇ (Fase 2)
              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         OSRM (Route Engine)             ‚îÇ
‚îÇ      Optimal Route Calculation          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Flujo de Datos

```
1. Usuario inicia tracking
   ‚Üì
2. Foreground Service captura GPS cada 5 min
   ‚Üì
3. App env√≠a coordenadas + metadata a API
   ‚Üì
4. Spring Boot valida token Firebase
   ‚Üì
5. Backend guarda en PostgreSQL (PostGIS)
   ‚Üì
6. Usuario solicita historial
   ‚Üì
7. Backend ejecuta queries geoespaciales
   ‚Üì
8. App visualiza ruta en flutter_map
```

---

## üîã Caracter√≠sticas T√©cnicas

### Tracking Inteligente

#### Configuraci√≥n de Captura
```dart
LocationSettings(
  accuracy: LocationAccuracy.balanced,  // No "high", ahorra bater√≠a
  distanceFilter: 50,                   // Solo si se movi√≥ >50m
  intervalDuration: Duration(minutes: 5) // Cada 5 minutos
)
```

#### Optimizaci√≥n de Bater√≠a
- **Consumo estimado:** 5-10% por d√≠a
- **Modo balanceado:** Usa torre celular + WiFi + GPS
- **Distance filter:** Evita updates innecesarios
- **Pausa autom√°tica:**
  - Si bater√≠a < 15%
  - Si usuario sin movimiento (STILL activity)
  - Si usuario lo solicita

#### Foreground Service (Android)
```xml
<!-- AndroidManifest.xml -->
<service
    android:name="ForegroundService"
    android:foregroundServiceType="location"
    android:exported="false" />
```

**Caracter√≠sticas:**
- ‚úÖ Funciona con pantalla apagada
- ‚úÖ Notificaci√≥n persistente obligatoria
- ‚úÖ No lo mata el sistema Android
- ‚úÖ Wake lock para GPS en background

#### iOS (Futuro - Fase 5)
```swift
// Usar "Significant Location Changes" en lugar de continuous
locationManager.startMonitoringSignificantLocationChanges()
// Consumo: <1% bater√≠a por d√≠a
```

### Datos Capturados por Punto

```json
{
  "user_id": "uuid-del-usuario",
  "latitude": -12.0464,
  "longitude": -77.0428,
  "timestamp": "2025-10-14T10:30:00Z",
  "accuracy": 15.5,        // metros
  "altitude": 150.0,       // metros sobre nivel del mar
  "speed": 5.2,            // metros/segundo
  "heading": 180.0,        // grados (0-360)
  "battery_level": 85,     // porcentaje
  "activity_type": "walking" // walking/driving/still
}
```

`activity_type` se obtiene usando la API de Activity Recognition de Google Play Services en Android (requiere el permiso `ACTIVITY_RECOGNITION`) y se deja planificado el soporte equivalente para iOS en la fase futura.

### M√©tricas de Performance

| M√©trica | Objetivo | Cr√≠tico |
|---------|----------|---------|
| Consumo bater√≠a | ‚â§ 10% / 8h | ‚â§ 15% / 8h |
| Captura exitosa | ‚â• 95% | ‚â• 90% |
| API response time | < 500ms | < 1000ms |
| Precisi√≥n GPS | ‚â§ 30m | ‚â§ 50m |
| Uptime app | > 99% | > 95% |

---

## üóÑÔ∏è Base de Datos

### Esquema PostgreSQL + PostGIS

#### Tabla: users
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  firebase_uid VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_firebase_uid ON users(firebase_uid);
```

#### Tabla: locations (Principal)
```sql
CREATE TABLE locations (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Geometr√≠a (tipo GEOGRAPHY para c√°lculos reales en metros)
  geom GEOGRAPHY(Point, 4326),  -- 4326 = WGS84 (GPS est√°ndar)
  
  -- Datos de telemetr√≠a
  timestamp TIMESTAMP NOT NULL,
  accuracy FLOAT,               -- Precisi√≥n en metros
  altitude FLOAT,               -- Metros sobre nivel del mar
  speed FLOAT,                  -- Metros por segundo
  heading FLOAT,                -- Grados (0-360, Norte = 0)
  
  -- Contexto
  battery_level INT,            -- Porcentaje 0-100
  activity_type VARCHAR(50),    -- walking, driving, still, etc.
  
  -- Metadata
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### √çndices Cr√≠ticos (OBLIGATORIOS)
```sql
-- √çndice espacial (GIST) - CR√çTICO para queries geoespaciales
CREATE INDEX idx_locations_geom ON locations USING GIST(geom);

-- √çndice compuesto para queries por usuario + tiempo
CREATE INDEX idx_locations_user_time ON locations(user_id, timestamp DESC);

-- √çndice para b√∫squedas por actividad
CREATE INDEX idx_locations_activity ON locations(user_id, activity_type)
  WHERE activity_type IS NOT NULL;

-- √çndice parcial para puntos recientes (optimizaci√≥n)
CREATE INDEX idx_locations_recent ON locations(user_id, timestamp DESC)
  WHERE timestamp > NOW() - INTERVAL '30 days';
```

### Preparaci√≥n de Base de Datos (Estado Actual)

1. **Infraestructura local**  
   - Contenedor `PostgreSQL 16 + PostGIS 3.4` levantado con `database/docker-compose.yml`.  
   - Ejecutar/replicar con:
     ```bash
     cd database
     docker compose up -d        # Crea contenedor y aplica schema.sql
     docker compose ps           # Verificar estado
     ```
   - El servicio expone `localhost:5432` con credenciales (`locationapp` / `change_me`).

2. **Esquema base aplicado**  
   - Script `database/schema.sql` con extensiones (`postgis`, `postgis_topology`, `pgcrypto`), tablas (`users`, `locations`), √≠ndices cr√≠ticos y trigger de `updated_at`.  
   - El mismo contenido est√° listo para herramientas de migraci√≥n en `database/migrations/V1__base_schema.sql`.

3. **Smoke test ejecutado**  
   - Script reproducible en `database/smoke_test.sql`; se corre con:
     ```bash
     cat database/smoke_test.sql | docker compose exec -T postgres psql -U locationapp -d location_tracker
     ```
   - Inserta/actualiza el usuario `smoke@example.com` y genera un registro en `locations` (ej. `location_id = 6`).  
   - Borrar los datos de prueba si se requiere una base limpia:
     ```sql
     DELETE FROM locations WHERE user_id = (SELECT id FROM users WHERE firebase_uid = 'smoke-uid');
     DELETE FROM users WHERE firebase_uid = 'smoke-uid';
     ```

4. **Notas operativas**  
   - El contenedor permanece activo tras las pruebas; detenerlo con `docker compose down` desde `database/`.  
   - Cambiar `POSTGRES_PASSWORD` antes de exponer el servicio fuera del entorno local.  
   - Integrar `migrations/V1__base_schema.sql` como `V1` al iniciar el backend (Flyway/Liquibase).

### Backend (Estado Actual)

1. **Proyecto Spring Boot 3.5.6 / Java 21**  
   - Estructura Gradle configurada en `backend/` con dependencias clave (`spring-web`, `spring-data-jpa`, `hibernate-spatial`, `springdoc`, `lombok`, `spring-boot-starter-validation`, `postgresql`, `jts-core`).  
   - Archivo principal `LocationBackendApplication.java` inicializa el servicio y expone endpoints REST en `/api`.  
   - Repositorios JPA (`UserRepository`, `LocationRecordRepository`) y entidades (`User`, `LocationRecord`) mapean PostGIS (`@JdbcTypeCode(SqlTypes.GEOMETRY)`).

2. **Servicios y Controladores**  
   - `UserController` (`POST /api/users`, `GET /api/users`, `GET /api/users/{firebaseUid}`) maneja alta/consulta de usuarios vinculados a Firebase.  
   - `LocationController` (`POST /api/locations`, `GET /api/locations/history`, `GET /api/locations/distance`) registra puntos, historial y distancia diaria calculada con `ST_Distance`.  
   - `LocationService` usa `GeometryFactory (SRID 4326)` y consultas nativas para sumar distancias.  
   - `GlobalExceptionHandler` estandariza errores de validaci√≥n (`400`) y recursos inexistentes (`404`).

3. **Ejecuci√≥n local (sin Gradle instalado globalmente)**  
   ```bash
   cd backend
   # Usa la distribuci√≥n descargada gradle-8.6/ y guarda caches en la carpeta del proyecto
   GRADLE_USER_HOME=$PWD/.gradle ./gradle-8.6/bin/gradle bootRun
   ```
   - Logs clave esperados:
     - `HikariPool-1 - Start completed`
     - `Tomcat started on port 8080`
     - `Started LocationBackendApplication`
   - Endpoints de verificaci√≥n:
     ```bash
     curl http://localhost:8080/api/health/db        # {"status":"UP","db":1}
     curl http://localhost:8080/swagger-ui           # Documentaci√≥n interactiva
     ```
   - Detener el backend con `Ctrl+C` en la terminal que ejecuta `bootRun`.

4. **Notas operativas**  
   - El backend depende de la base `location_tracker` levantada con `docker compose up -d` en `database/`.  
   - Cualquier error de permisos de ubicaci√≥n PostGIS se resuelve usando el dialecto `org.hibernate.spatial.dialect.postgis.PostgisPG95Dialect` (configurado en `application.yml`).  
   - Validaciones (`@Valid`) requieren `spring-boot-starter-validation`, ya incorporado.

### Queries Principales

#### 1. Guardar Ubicaci√≥n
```sql
INSERT INTO locations (
  user_id, 
  geom, 
  timestamp, 
  accuracy, 
  speed, 
  battery_level,
  activity_type
) VALUES (
  $1,  -- user_id
  ST_SetSRID(ST_MakePoint($2, $3), 4326),  -- lng, lat
  $4,  -- timestamp
  $5,  -- accuracy
  $6,  -- speed
  $7,  -- battery
  $8   -- activity
) RETURNING id;
```

#### 2. Obtener Historial de un D√≠a
```sql
SELECT 
  id,
  ST_Y(geom::geometry) as latitude,
  ST_X(geom::geometry) as longitude,
  timestamp,
  accuracy,
  speed,
  battery_level,
  activity_type
FROM locations
WHERE user_id = $1
  AND timestamp >= $2  -- inicio del d√≠a
  AND timestamp < $3   -- fin del d√≠a
ORDER BY timestamp ASC;
```

#### 3. Calcular Distancia Recorrida en un D√≠a
```sql
WITH ordered_points AS (
  SELECT 
    geom,
    timestamp,
    LAG(geom) OVER (ORDER BY timestamp) as prev_geom
  FROM locations
  WHERE user_id = $1
    AND timestamp::date = $2
)
SELECT 
  COALESCE(
    SUM(ST_Distance(geom, prev_geom)) / 1000,  -- Convertir a km
    0
  ) as total_km
FROM ordered_points
WHERE prev_geom IS NOT NULL;
```

#### 4. Lugares M√°s Visitados (Heatmap)
```sql
SELECT 
  ST_AsGeoJSON(ST_Centroid(ST_Collect(geom::geometry)))::json as center,
  COUNT(*) as visit_count,
  MIN(timestamp) as first_visit,
  MAX(timestamp) as last_visit,
  EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp)))/3600 as hours_spent
FROM locations
WHERE user_id = $1
  AND timestamp > NOW() - INTERVAL '30 days'
GROUP BY ST_SnapToGrid(geom::geometry, 0.001)  -- ~100m de precisi√≥n
HAVING COUNT(*) > 5  -- M√≠nimo 5 visitas
ORDER BY visit_count DESC
LIMIT 10;
```

#### 5. Puntos Cerca de una Ubicaci√≥n
```sql
SELECT 
  id,
  ST_Y(geom::geometry) as latitude,
  ST_X(geom::geometry) as longitude,
  timestamp,
  ST_Distance(
    geom,
    ST_SetSRID(ST_MakePoint($2, $3), 4326)
  ) as distance_meters
FROM locations
WHERE user_id = $1
  AND ST_DWithin(
    geom,
    ST_SetSRID(ST_MakePoint($2, $3), 4326),
    500  -- Radio en metros
  )
ORDER BY distance_meters
LIMIT 20;
```

#### 6. Ruta del D√≠a como LineString (GeoJSON)
```sql
SELECT 
  ST_AsGeoJSON(ST_MakeLine(geom::geometry ORDER BY timestamp))::json as route_geojson,
  COUNT(*) as point_count,
  MIN(timestamp) as start_time,
  MAX(timestamp) as end_time
FROM locations
WHERE user_id = $1
  AND timestamp::date = $2
GROUP BY user_id
HAVING COUNT(*) > 1;
```

#### 7. Estad√≠sticas Semanales
```sql
SELECT 
  DATE(timestamp) as day,
  COUNT(*) as points_captured,
  ROUND(
    SUM(ST_Distance(geom, LAG(geom) OVER (ORDER BY timestamp))) / 1000
  , 2) as distance_km,
  MIN(battery_level) as min_battery,
  MAX(battery_level) as max_battery
FROM locations
WHERE user_id = $1
  AND timestamp > NOW() - INTERVAL '7 days'
GROUP BY DATE(timestamp)
ORDER BY day DESC;
```

### Mantenimiento y Optimizaci√≥n

#### Particionamiento (Para escala)
```sql
-- Si tienes millones de registros, particiona por mes
CREATE TABLE locations_2025_10 PARTITION OF locations
FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

CREATE TABLE locations_2025_11 PARTITION OF locations
FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

#### Vacuum y Analyze Autom√°tico
```sql
-- PostgreSQL lo hace autom√°tico, pero puedes forzarlo
VACUUM ANALYZE locations;

-- Para liberar espacio despu√©s de borrar datos antiguos
VACUUM FULL locations;
```

#### Eliminar Datos Antiguos (GDPR compliance)
```sql
-- Eliminar ubicaciones > 1 a√±o
DELETE FROM locations
WHERE timestamp < NOW() - INTERVAL '1 year';

-- O archivar en tabla hist√≥rica
INSERT INTO locations_archive
SELECT * FROM locations
WHERE timestamp < NOW() - INTERVAL '1 year';

DELETE FROM locations
WHERE timestamp < NOW() - INTERVAL '1 year';
```

---

## üìÖ Plan de Desarrollo

### üë• Equipo: 2 Personas | ‚è±Ô∏è Tiempo: 3 Semanas

---

### üìÜ SEMANA 1: Setup e Implementaci√≥n Base

#### **Persona 1 - Backend & Infraestructura**

##### D√≠a 1-2: Setup del Servidor
```bash
# 1. Instalar Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER

# 2. Levantar PostgreSQL + PostGIS
docker run --name location-postgres \
  -e POSTGRES_USER=locationapp \
  -e POSTGRES_PASSWORD=change_me \
  -e POSTGRES_DB=location_tracker \
  -p 5432:5432 \
  -v /var/lib/postgresql/data:/var/lib/postgresql/data \
  --restart always \
  -d postgis/postgis:16-3.4

# 3. Verificar
docker ps
docker logs location-postgres
```

##### D√≠a 3-4: Estructura de Base de Datos
```sql
-- Conectarse
docker exec -it location-postgres psql -U locationapp -d location_tracker

-- Habilitar PostGIS
CREATE EXTENSION postgis;
CREATE EXTENSION postgis_topology;

-- Verificar
SELECT PostGIS_version();

-- Crear tablas (usar scripts de secci√≥n "Base de Datos")
-- Crear √≠ndices
-- Poblar datos de prueba
```

##### D√≠a 5-7: API Backend Spring Boot
```bash
# 1. Crear proyecto en https://start.spring.io/
# 2. Configurar dependencias (ver secci√≥n Stack)
# 3. Implementar:
#    - Entities (User, Location)
#    - Repositories (LocationRepository)
#    - Services (LocationService)
#    - Controllers (LocationController)
#    - Security (Firebase JWT validation)
```

**Endpoints a implementar:**
- `POST /api/locations` - Guardar ubicaci√≥n
- `GET /api/locations/history` - Historial
- `GET /api/stats/distance` - Distancia del d√≠a

**Testing:**
```bash
# Test con curl
curl -X POST http://localhost:8080/api/locations \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "latitude": -12.0464,
    "longitude": -77.0428,
    "timestamp": "2025-10-14T10:30:00Z",
    "accuracy": 15.5,
    "speed": 5.2,
    "batteryLevel": 85
  }'
```

---

#### **Persona 2 - Frontend Flutter**

##### D√≠a 1-2: Setup Proyecto Flutter
```bash
# 1. Crear proyecto
flutter create location_tracker_app
cd location_tracker_app

# 2. Agregar dependencias en pubspec.yaml
# (ver secci√≥n Stack Tecnol√≥gico)

# 3. Verificar
flutter doctor
flutter pub get
```

##### D√≠a 3-4: Configuraci√≥n Android & Firebase

**android/app/src/main/AndroidManifest.xml:**
```xml
<manifest>
    <!-- Permisos -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.ACTIVITY_RECOGNITION" />
    
    <application>
        <!-- Foreground service -->
        <service
            android:name="com.pravera.flutter_foreground_task.service.ForegroundService"
            android:foregroundServiceType="location"
            android:exported="false" />
    </application>
</manifest>
```

**Configurar Firebase:**
1. Crear proyecto en Firebase Console
2. Agregar app Android
3. Descargar `google-services.json` ‚Üí `android/app/`
4. Configurar `android/build.gradle` y `android/app/build.gradle`

##### D√≠a 5-7: Implementaci√≥n Core

**Estructura de carpetas:**
```
lib/
‚îú‚îÄ‚îÄ main.dart
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ constants.dart
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ location_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ api_service.dart
‚îÇ   ‚îî‚îÄ‚îÄ auth_service.dart
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ location_point.dart
‚îÇ   ‚îî‚îÄ‚îÄ user_model.dart
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ login_screen.dart
‚îÇ   ‚îú‚îÄ‚îÄ map_screen.dart
‚îÇ   ‚îî‚îÄ‚îÄ history_screen.dart
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îú‚îÄ‚îÄ location_map.dart
‚îÇ   ‚îî‚îÄ‚îÄ stats_card.dart
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ date_helpers.dart
```

**Implementar:**
1. `LocationService` - Captura GPS y foreground service
2. `ApiService` - Comunicaci√≥n con backend
3. `AuthService` - Login con Firebase
4. `MapScreen` - Visualizaci√≥n b√°sica

---

### üìÜ SEMANA 2: Integraci√≥n & Testing

#### D√≠a 8-9: Conexi√≥n End-to-End
**Ambos trabajando juntos:**
- Conectar Flutter con Spring Boot API
- Configurar Firebase en backend (validaci√≥n tokens)
- Probar flujo completo:
  1. Login ‚Üí Token
  2. Captura GPS ‚Üí Env√≠o a API
  3. Query historial ‚Üí Visualizaci√≥n

**Checklist:**
- [ ] Login funcional
- [ ] Captura GPS cada 5 min
- [ ] Datos llegando a PostgreSQL
- [ ] Query historial funcionando
- [ ] Mapa mostrando ruta

#### D√≠a 10-11: Testing de Tracking Continuo
**Pruebas:**
- Dejar app corriendo 4+ horas
- Monitorear consumo de bater√≠a
- Verificar todos los puntos capturados
- Probar con/sin movimiento
- Probar con pantalla apagada

**M√©tricas a medir:**
```
- Puntos capturados vs esperados: ___%
- Bater√≠a consumida en 4h: ___%
- Precisi√≥n promedio: ___m
- Crashes o errores: ___
- Response time API: ___ms
```

#### D√≠a 12: Optimizaciones
**Basado en testing:**
- Ajustar `distanceFilter` (50m, 100m, 200m?)
- Optimizar frecuencia si bater√≠a cr√≠tica
- Mejorar queries lentas en backend
- Cachear datos en app

#### D√≠a 13: Features de Optimizaci√≥n
**Implementar:**
- Pausa autom√°tica si bater√≠a < 15%
- Detector de actividad (pausa si STILL)
- Configuraci√≥n de frecuencia por usuario
- Modo "eco" (reduce precisi√≥n)

#### D√≠a 14: Testing en Dispositivos Reales
**Probar en m√∫ltiples dispositivos:**
- Android 10, 11, 12, 13, 14
- Diferentes fabricantes (Samsung, Xiaomi, etc.)
- Con/sin Google Play Services
- Diferentes condiciones de red

---

### üìÜ SEMANA 3: Features Adicionales & Polish

#### Persona 1 - Backend (D√≠a 15-21)

##### Features adicionales:
```java
// 1. Endpoint de estad√≠sticas avanzadas
GET /api/stats/weekly?userId=X
GET /api/stats/places/frequent?userId=X&days=30

// 2. Export de datos
GET /api/export/csv?userId=X&start=&end=
GET /api/export/geojson?userId=X&start=&end=

// 3. Configuraci√≥n de usuario
PUT /api/user/settings
{
  "trackingFrequency": 300,  // segundos
  "minBatteryLevel": 15,
  "pauseWhenStill": true
}
```

##### Optimizaciones DB:
- Indices adicionales seg√∫n queries lentas
- Connection pooling configurado
- Query caching para estad√≠sticas

##### Preparar OSRM (opcional):
```bash
# Descargar datos de Per√∫
wget http://download.geofabrik.de/south-america/peru-latest.osm.pbf

# Procesar
docker run -t -v $(pwd):/data ghcr.io/project-osrm/osrm-backend osrm-extract -p /opt/car.lua /data/peru-latest.osm.pbf
docker run -t -v $(pwd):/data ghcr.io/project-osrm/osrm-backend osrm-partition /data/peru-latest.osrm
docker run -t -v $(pwd):/data ghcr.io/project-osrm/osrm-backend osrm-customize /data/peru-latest.osrm

# Iniciar servidor
docker run -t -i -p 5000:5000 -v $(pwd):/data ghcr.io/project-osrm/osrm-backend osrm-routed --algorithm mld /data/peru-latest.osrm
```

---

#### Persona 2 - Frontend (D√≠a 15-21)

##### Pantallas adicionales:

**1. Pantalla de Historial:**
```dart
// history_screen.dart
- DateRangePicker para seleccionar fechas
- Lista de d√≠as con:
  * Distancia recorrida
  * Tiempo activo
  * Puntos capturados
- Tap en d√≠a ‚Üí ver mapa de ese d√≠a
```

**2. Dashboard de Estad√≠sticas:**
```dart
// dashboard_screen.dart
- Distancia total (semanal, mensual)
- Lugares m√°s visitados (top 5)
- Gr√°fico de actividad por d√≠a
- Promedio de bater√≠a consumida
```

**3. Configuraci√≥n:**
```dart
// settings_screen.dart
- Frecuencia de tracking (slider)
- Pausa por bater√≠a (switch + nivel)
- Pausa si no hay movimiento (switch)
- Eliminar datos antiguos
- Exportar datos
- Cerrar sesi√≥n
```

##### Mejoras UI/UX:
- Animaciones de transici√≥n
- Loading states
- Error handling con mensajes claros
- Dark mode (opcional)
- Iconos y colores consistentes

##### Testing:
- Widget tests de pantallas principales
- Integration tests del flujo completo

---

### üéØ Entregables Finales (D√≠a 21)

#### Documentaci√≥n:
- [ ] README.md con instrucciones de instalaci√≥n
- [ ] API documentation (endpoints, request/response)
- [ ] Gu√≠a de despliegue en servidor
- [ ] Gu√≠a de uso para testers

#### C√≥digo:
- [ ] Repositorio Git organizado
- [ ] Backend Spring Boot completo
- [ ] App Flutter compilada (.apk)
- [ ] Scripts SQL de base de datos
- [ ] Docker Compose para infraestructura

#### Testing:
- [ ] Reporte de pruebas (bater√≠a, precisi√≥n, estabilidad)
- [ ] Lista de bugs conocidos
- [ ] Screenshots de la app funcionando

---

## üöÄ Gu√≠a de Setup

### Requisitos Previos

#### Servidor:
- Ubuntu 20.04+ o similar
- 4GB RAM m√≠nimo (8GB recomendado)
- 20GB almacenamiento
- Docker instalado
- Puerto 5432 (PostgreSQL) y 8080 (API) abiertos

#### Desarrollo:
- Java 21 (backend)
- Gradle 8.6+ (backend)
- Flutter 3.16+ (frontend)
- Android Studio (frontend)
- Git

---

### Setup Backend (Spring Boot)

#### 1. Preparar entorno
```bash
# Requiere JDK 21 y Gradle 8.6+
cd backend

# Opcional: exportar credenciales (coinciden con database/docker-compose.yml)
export SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/location_tracker
export SPRING_DATASOURCE_USERNAME=locationapp
export SPRING_DATASOURCE_PASSWORD=change_me
```

#### 2. Ejecutar aplicaci√≥n
```bash
# Arrancar el backend apuntando a la base PostGIS
gradle bootRun

# Con wrapper (si se agrega)
# ./gradlew bootRun
```

#### 3. Verificar conexi√≥n
```bash
# Endpoint de salud que ejecuta SELECT 1
curl http://localhost:8080/api/health/db
# Respuesta esperada: {"status":"UP","db":1}

# Documentaci√≥n OpenAPI
# Abrir en navegador: http://localhost:8080/swagger-ui
```

---

### Setup Frontend (Flutter)

#### 1. Clonar y configurar
```bash
git clone <repo-url>
cd location_tracker_app

flutter pub get
```

#### 2. Configurar Firebase
```bash
# Descargar google-services.json de Firebase Console
# Colocar en: android/app/google-services.json

# Configurar Firebase en c√≥digo
# Editar: lib/config/constants.dart
```

#### 3. Configurar URL del backend
```dart
// lib/config/constants.dart
class Constants {
  static const String apiBaseUrl = 'http://TU_IP_SERVIDOR:8080/api';
  // O en producci√≥n:
  // static const String apiBaseUrl = 'https://api.tudominio.com/api';
}
```

#### 4. Ejecutar en dispositivo
```bash
# Verificar dispositivo conectado
flutter devices

# Ejecutar
  flutter run  
  flutter run -d emulator-5554  # tras iniciar ~/Android/Sdk/emulator/emulator -avd flutter_emulator

# O compilar APK
flutter build apk --release
# APK en: build/app/outputs/flutter-apk/app-release.apk
```

---

### Setup Base de Datos (PostgreSQL + PostGIS)

#### Docker Compose (Recomendado)
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgis/postgis:16-3.4
    container_name: postgis-location
    environment:
      POSTGRES_DB: location_tracker
      POSTGRES_USER: locationapp
      POSTGRES_PASSWORD: CAMBIAR_PASSWORD
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: always

  api:
    build: ./location-api
    container_name: location-api
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/location_tracker
      SPRING_DATASOURCE_USERNAME: locationapp
      SPRING_DATASOURCE_PASSWORD: CAMBIAR_PASSWORD
    ports:
      - "8080:8080"
    depends_on:
      - postgres
    restart: always

volumes:
  postgres_data:
```

```bash
# Levantar todo
docker-compose up -d

# Ver logs
docker-compose logs -f

# Detener
docker-compose down
```

#### Script de inicializaci√≥n (init.sql)
```sql
-- Este archivo se ejecuta autom√°ticamente al crear el contenedor

-- Habilitar PostGIS
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;

-- Crear tablas
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  firebase_uid VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE locations (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  geom GEOGRAPHY(Point, 4326),
  timestamp TIMESTAMP NOT NULL,
  accuracy FLOAT,
  altitude FLOAT,
  speed FLOAT,
  heading FLOAT,
  battery_level INT,
  activity_type VARCHAR(50),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Crear √≠ndices
CREATE INDEX idx_locations_geom ON locations USING GIST(geom);
CREATE INDEX idx_locations_user_time ON locations(user_id, timestamp DESC);
CREATE INDEX idx_users_firebase_uid ON users(firebase_uid);

-- Datos de prueba (opcional)
-- INSERT INTO users (email, firebase_uid) VALUES ('test@example.com', 'test-uid-123');
```

---

## üí∞ Costos y Recursos

### Costos Mensuales (Estimados)

| Servicio | Plan | Costo |
|----------|------|-------|
| Servidor propio | Ya disponible | $0 |
| Firebase Auth | Free tier | $0 (hasta 50k usuarios) |
| OpenStreetMap | Gratis | $0 |
| Dominio | .com | $12/a√±o = $1/mes |
| SSL Certificate | Let's Encrypt | $0 |
| **TOTAL** | | **~$1/mes** |

### Escalabilidad - Costos Futuros

Si necesitas escalar (miles de usuarios):

| Usuarios Activos | Servidor VPS | Base de Datos | Total/mes |
|------------------|--------------|---------------|-----------|
| 100 | Actual | Actual | $0 |
| 1,000 | DigitalOcean 4GB ($24) | Actual | $24 |
| 10,000 | DigitalOcean 8GB ($48) | Managed DB ($15) | $63 |
| 100,000 | AWS EC2 ($100+) | AWS RDS ($150+) | $250+ |

### Recursos del Servidor

**Configuraci√≥n M√≠nima (PoC):**
- CPU: 2 cores
- RAM: 4GB
- Storage: 20GB SSD
- Bandwidth: Ilimitado

**Configuraci√≥n Recomendada:**
- CPU: 4 cores
- RAM: 8GB
- Storage: 50GB SSD
- Bandwidth: Ilimitado

**Crecimiento de Storage:**
```
1 punto GPS = ~150 bytes en DB
1 usuario = 288 puntos/d√≠a (cada 5 min)
1 usuario = ~43KB/d√≠a = 1.3MB/mes

100 usuarios = 130MB/mes
1,000 usuarios = 1.3GB/mes
10,000 usuarios = 13GB/mes
```

---

## üì± C√≥digo de Referencia

### Backend - Spring Boot

- **UserController (`/api/users`)**
  - `POST /api/users` crea o actualiza un usuario a partir de `firebaseUid` + email.
  - `GET /api/users/{firebaseUid}` recupera el usuario registrado.
  - `GET /api/users` lista todos los usuarios registrados (√∫til para debugging).

- **LocationController (`/api/locations`)**
  - `POST /api/locations` guarda un punto geoespacial. El backend convierte `latitude/longitude` en un `Point` SRID 4326 usando JTS + PostGIS.
  - `GET /api/locations/history?firebaseUid=UID&start=2025-10-15T00:00:00Z&end=2025-10-16T00:00:00Z` devuelve los puntos en el rango y la distancia (km) calculada con PostGIS.
  - `GET /api/locations/distance?firebaseUid=UID&date=2025-10-15` calcula distancia diaria (km) usando `ST_Distance` sobre `geography`.

- **L√≥gica clave**
  - `LocationService` se apoya en `GeometryFactory` (SRID 4326) para crear `Point` y delega en consultas nativas de PostGIS para c√°lculo de distancias acumuladas.
  - `LocationRecordRepository` incorpora un `WINDOW FUNCTION + ST_Distance` para sumar tramos consecutivos en la base.
  - `UserService` centraliza la b√∫squeda/creaci√≥n de usuarios vinculados a Firebase.

- **Validaci√≥n y manejo de errores**
  - Se agreg√≥ `spring-boot-starter-validation` para validar DTOs (`@NotBlank`, `@DecimalMin`, etc.).
  - `GlobalExceptionHandler` traduce errores de validaci√≥n a `400` y recursos inexistentes a `404`.

Fragmento de request para crear ubicaci√≥n:

```bash
curl -X POST http://localhost:8080/api/locations \
  -H "Content-Type: application/json" \
  -d '{
        "firebaseUid": "uid-123",
        "latitude": -12.0464,
        "longitude": -77.0428,
        "timestamp": "2025-10-15T12:00:00Z",
        "batteryLevel": 88,
        "activityType": "walking"
      }'
```

Respuesta resumida:

```json
{
  "id": 42,
  "latitude": -12.0464,
  "longitude": -77.0428,
  "timestamp": "2025-10-15T12:00:00Z",
  "batteryLevel": 88,
  "activityType": "walking"
}
```

---

### Frontend - Flutter

#### location_service.dart
```dart
import 'package:geolocator/geolocator.dart';
import 'package:flutter_foreground_task/flutter_foreground_task.dart';
import 'api_service.dart';

class LocationService {
  static bool _isTracking = false;
  
  /// Iniciar tracking de ubicaci√≥n
  static Future<void> startTracking() async {
    if (_isTracking) return;
    
    // Verificar permisos
    bool hasPermission = await _checkPermissions();
    if (!hasPermission) {
      throw Exception('Permisos de ubicaci√≥n denegados');
    }
    
    // Configurar foreground task
    await FlutterForegroundTask.init(
      androidNotificationOptions: AndroidNotificationOptions(
        channelId: 'location_tracking',
        channelName: 'Tracking de Ubicaci√≥n',
        channelDescription: 'Guardando tu ubicaci√≥n cada 5 minutos',
        channelImportance: NotificationChannelImportance.LOW,
        priority: NotificationPriority.LOW,
        iconData: const NotificationIconData(
          resType: ResourceType.mipmap,
          resPrefix: ResourcePrefix.ic,
          name: 'launcher',
        ),
      ),
      iosNotificationOptions: const IOSNotificationOptions(
        showNotification: true,
        playSound: false,
      ),
      foregroundTaskOptions: const ForegroundTaskOptions(
        interval: 300000, // 5 minutos en milisegundos
        isOnceEvent: false,
        autoRunOnBoot: false,
        allowWakeLock: true,
        allowWifiLock: false,
      ),
    );
    
    // Iniciar servicio
    bool started = await FlutterForegroundTask.startService(
      notificationTitle: 'Tracking activo',
      notificationText: 'Guardando ubicaci√≥n cada 5 minutos',
      callback: startCallback,
    );
    
    if (started) {
      _isTracking = true;
    }
  }
  
  /// Detener tracking
  static Future<void> stopTracking() async {
    await FlutterForegroundTask.stopService();
    _isTracking = false;
  }
  
  /// Obtener ubicaci√≥n actual una vez
  static Future<Position?> getCurrentLocation() async {
    try {
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
      }
      
      if (permission == LocationPermission.deniedForever ||
          permission == LocationPermission.denied) {
        return null;
      }
      
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.balanced,
      );
      
      return position;
    } catch (e) {
      print('Error obteniendo ubicaci√≥n: $e');
      return null;
    }
  }
  
  /// Verificar permisos
  static Future<bool> _checkPermissions() async {
    LocationPermission permission = await Geolocator.checkPermission();
    
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
    }
    
    return permission != LocationPermission.denied &&
           permission != LocationPermission.deniedForever;
  }
  
  /// Estado del tracking
  static bool get isTracking => _isTracking;
}

/// Callback del foreground task
@pragma('vm:entry-point')
void startCallback() {
  FlutterForegroundTask.setTaskHandler(LocationTaskHandler());
}

/// Handler que se ejecuta cada 5 minutos
class LocationTaskHandler extends TaskHandler {
  int _eventCount = 0;
  
  @override
  Future<void> onStart(DateTime timestamp, SendPort? sendPort) async {
    print('Location tracking started at $timestamp');
  }
  
  @override
  Future<void> onRepeatEvent(DateTime timestamp, SendPort? sendPort) async {
    _eventCount++;
    print('Location event #$_eventCount at $timestamp');
    
    try {
      // Obtener ubicaci√≥n
      Position? position = await LocationService.getCurrentLocation();
      
      if (position != null) {
        // Obtener nivel de bater√≠a
        int batteryLevel = await _getBatteryLevel();
        
        // Verificar si debe pausar por bater√≠a baja
        if (batteryLevel < 15) {
          print('Bater√≠a baja ($batteryLevel%), pausando tracking');
          await LocationService.stopTracking();
          return;
        }
        
        // Enviar al backend
        bool success = await ApiService.saveLocation(
          latitude: position.latitude,
          longitude: position.longitude,
          accuracy: position.accuracy,
          altitude: position.altitude,
          speed: position.speed,
          heading: position.heading,
          timestamp: DateTime.now(),
          batteryLevel: batteryLevel,
        );
        
        if (success) {
          print('Ubicaci√≥n guardada: ${position.latitude}, ${position.longitude}');
          
          // Actualizar notificaci√≥n
          FlutterForegroundTask.updateService(
            notificationText: '√öltima ubicaci√≥n: ${DateTime.now().toString().substring(11, 16)}',
          );
        } else {
          print('Error guardando ubicaci√≥n en el servidor');
        }
      } else {
        print('No se pudo obtener ubicaci√≥n GPS');
      }
    } catch (e) {
      print('Error en LocationTaskHandler: $e');
    }
  }
  
  @override
  Future<void> onDestroy(DateTime timestamp, SendPort? sendPort) async {
    print('Location tracking stopped at $timestamp');
  }
  
  /// Obtener nivel de bater√≠a
  Future<int> _getBatteryLevel() async {
    // Implementar con battery_plus
    return 100; // Placeholder
  }
}
```

#### api_service.dart
```dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../config/constants.dart';
import 'auth_service.dart';

class ApiService {
  /// Guardar ubicaci√≥n en el backend
  static Future<bool> saveLocation({
    required double latitude,
    required double longitude,
    required double accuracy,
    double? altitude,
    double? speed,
    double? heading,
    required DateTime timestamp,
    int? batteryLevel,
    String? activityType,
  }) async {
    try {
      String? token = await AuthService.getIdToken();
      if (token == null) return false;
      
      final response = await http.post(
        Uri.parse('${Constants.apiBaseUrl}/locations'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: jsonEncode({
          'latitude': latitude,
          'longitude': longitude,
          'accuracy': accuracy,
          'altitude': altitude,
          'speed': speed,
          'heading': heading,
          'timestamp': timestamp.toIso8601String(),
          'batteryLevel': batteryLevel,
          'activityType': activityType,
        }),
      );
      
      return response.statusCode == 200;
    } catch (e) {
      print('Error guardando ubicaci√≥n: $e');
      return false;
    }
  }
  
  /// Obtener historial de ubicaciones
  static Future<List<LocationPoint>> getHistory({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      String? token = await AuthService.getIdToken();
      if (token == null) return [];
      
      final response = await http.get(
        Uri.parse(
          '${Constants.apiBaseUrl}/locations/history'
          '?startDate=${startDate.toIso8601String()}'
          '&endDate=${endDate.toIso8601String()}'
        ),
        headers: {
          'Authorization': 'Bearer $token',
        },
      );
      
      if (response.statusCode == 200) {
        List<dynamic> data = jsonDecode(response.body);
        return data.map((json) => LocationPoint.fromJson(json)).toList();
      }
      
      return [];
    } catch (e) {
      print('Error obteniendo historial: $e');
      return [];
    }
  }
  
  /// Obtener distancia recorrida en un d√≠a
  static Future<double> getDistanceForDay(DateTime date) async {
    try {
      String? token = await AuthService.getIdToken();
      if (token == null) return 0.0;
      
      final response = await http.get(
        Uri.parse(
          '${Constants.apiBaseUrl}/stats/distance'
          '?date=${date.toIso8601String()}'
        ),
        headers: {
          'Authorization': 'Bearer $token',
        },
      );
      
      if (response.statusCode == 200) {
        return double.parse(response.body);
      }
      
      return 0.0;
    } catch (e) {
      print('Error obteniendo distancia: $e');
      return 0.0;
    }
  }
}
```

#### map_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import '../services/location_service.dart';
import '../services/api_service.dart';
import '../models/location_point.dart';

class MapScreen extends StatefulWidget {
  @override
  _MapScreenState createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  List<LatLng> routePoints = [];
  bool isTracking = false;
  bool isLoading = true;
  double distanceKm = 0.0;
  
  @override
  void initState() {
    super.initState();
    _loadTodayRoute();
    isTracking = LocationService.isTracking;
  }
  
  Future<void> _loadTodayRoute() async {
    setState(() => isLoading = true);
    
    DateTime now = DateTime.now();
    DateTime startOfDay = DateTime(now.year, now.month, now.day);
    DateTime endOfDay = startOfDay.add(Duration(days: 1));
    
    try {
      // Obtener puntos del d√≠a
      List<LocationPoint> points = await ApiService.getHistory(
        startDate: startOfDay,
        endDate: endOfDay,
      );
      
      // Obtener distancia
      double distance = await ApiService.getDistanceForDay(startOfDay);
      
      setState(() {
        routePoints = points
            .map((p) => LatLng(p.latitude, p.longitude))
            .toList();
        distanceKm = distance;
        isLoading = false;
      });
    } catch (e) {
      print('Error cargando ruta: $e');
      setState(() => isLoading = false);
    }
  }
  
  Future<void> _toggleTracking() async {
    if (isTracking) {
      await LocationService.stopTracking();
      setState(() => isTracking = false);
    } else {
      try {
        await LocationService.startTracking();
        setState(() => isTracking = true);
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Mi Ubicaci√≥n'),
        actions: [
          IconButton(
            icon: Icon(Icons.refresh),
            onPressed: _loadTodayRoute,
          ),
        ],
      ),
      body: Stack(
        children: [
          // Mapa
          FlutterMap(
            options: MapOptions(
              center: routePoints.isNotEmpty 
                  ? routePoints.first 
                  : LatLng(-12.0464, -77.0428),
              zoom: 13.0,
            ),
            children: [
              // Capa de tiles (OpenStreetMap)
              TileLayer(
                urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                userAgentPackageName: 'com.example.location_tracker',
              ),
              
              // L√≠nea de ruta
              if (routePoints.length > 1)
                PolylineLayer(
                  polylines: [
                    Polyline(
                      points: routePoints,
                      strokeWidth: 4.0,
                      color: Colors.blue,
                    ),
                  ],
                ),
              
              // Marcadores
              if (routePoints.isNotEmpty)
                MarkerLayer(
                  markers: [
                    // Punto inicial (verde)
                    Marker(
                      point: routePoints.first,
                      width: 40,
                      height: 40,
                      builder: (ctx) => Icon(
                        Icons.location_on,
                        color: Colors.green,
                        size: 40,
                      ),
                    ),
                    // Punto final/actual (rojo)
                    Marker(
                      point: routePoints.last,
                      width: 40,
                      height: 40,
                      builder: (ctx) => Icon(
                        Icons.location_on,
                        color: Colors.red,
                        size: 40,
                      ),
                    ),
                  ],
                ),
            ],
          ),
          
          // Indicador de carga
          if (isLoading)
            Center(
              child: CircularProgressIndicator(),
            ),
          
          // Card de estad√≠sticas
          Positioned(
            top: 16,
            left: 16,
            right: 16,
            child: Card(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      'Hoy',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    SizedBox(height: 8),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('Puntos capturados'),
                            Text(
                              '${routePoints.length}',
                              style: TextStyle(
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                                color: Colors.blue,
                              ),
                            ),
                          ],
                        ),
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('Distancia'),
                            Text(
                              '${distanceKm.toStringAsFixed(2)} km',
                              style: TextStyle(
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                                color: Colors.green,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
      
      // Bot√≥n de tracking
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _toggleTracking,
        label: Text(isTracking ? 'Detener' : 'Iniciar'),
        icon: Icon(isTracking ? Icons.stop : Icons.play_arrow),
        backgroundColor: isTracking ? Colors.red : Colors.green,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }
}
```

---

## üöÄ Roadmap

### Fase 1: PoC (Semanas 1-3) ‚úÖ
**Objetivo:** Validar concepto con funcionalidad m√≠nima

- [x] Setup infraestructura (servidor, DB, Firebase)
- [x] Backend Spring Boot con endpoints b√°sicos
- [x] App Flutter con tracking y visualizaci√≥n
- [x] Integraci√≥n end-to-end funcional
- [x] Testing de bater√≠a y precisi√≥n

**Entregable:** App Android funcional + Backend desplegado

---

### Fase 2: Features Core (Mes 2)
**Objetivo:** Completar funcionalidades principales

#### Backend:
- [ ] Endpoint de estad√≠sticas avanzadas
- [ ] Export de datos (CSV, GeoJSON)
- [ ] API de configuraci√≥n de usuario
- [ ] Optimizaci√≥n de queries (indices, caching)
- [ ] Logging y monitoreo

#### Frontend:
- [ ] Pantalla de historial con calendario
- [ ] Dashboard de estad√≠sticas
- [ ] Configuraci√≥n de tracking
- [ ] Notificaciones push
- [ ] Manejo de errores robusto

#### Infraestructura:
- [ ] HTTPS con SSL (Let's Encrypt)
- [ ] Backup autom√°tico de DB
- [ ] CI/CD pipeline b√°sico

**Entregable:** App completa lista para beta testers

---

### Fase 3: An√°lisis Avanzado (Mes 3)
**Objetivo:** Rutas √≥ptimas y an√°lisis inteligente

#### Rutas:
- [ ] Integraci√≥n OSRM (self-hosted)
- [ ] C√°lculo de rutas √≥ptimas entre puntos
- [ ] Comparaci√≥n ruta real vs √≥ptima
- [ ] Sugerencias de mejora

#### An√°lisis:
- [ ] Detecci√≥n autom√°tica de "hogar" y "trabajo"
- [ ] Patrones de movimiento (d√≠as laborales vs fines de semana)
- [ ] Heatmap de zonas m√°s frecuentadas
- [ ] Predicci√≥n de pr√≥xima ubicaci√≥n

#### UI:
- [ ] Visualizaci√≥n de rutas optimizadas
- [ ] Gr√°ficos y reportes
- [ ] Comparativas temporales

**Entregable:** Sistema de an√°lisis funcional

---

### Fase 4: iOS (Mes 4)
**Objetivo:** Soporte multiplataforma completo

- [ ] Port a iOS de la app Flutter
- [ ] Configuraci√≥n de permisos iOS
- [ ] Background location (significant changes)
- [ ] TestFlight beta
- [ ] App Store submission

**Entregable:** App iOS en TestFlight

---

### Fase 5: Features Premium (Mes 5+)
**Objetivo:** Monetizaci√≥n y features avanzadas

#### Social:
- [ ] Compartir ubicaci√≥n en tiempo real
- [ ] Grupos/familias
- [ ] Chat entre miembros del grupo

#### Geofencing:
- [ ] Crear zonas personalizadas
- [ ] Alertas al entrar/salir
- [ ] Notificaciones autom√°ticas

#### Integraci√≥n:
- [ ] Export a Google Timeline
- [ ] Import desde otras apps
- [ ] API p√∫blica para terceros

#### Gamificaci√≥n:
- [ ] Logros por distancia
- [ ] Ranking entre amigos
- [ ] Desaf√≠os semanales

**Entregable:** App completa con features premium

---

### Fase 6: Escalabilidad (Mes 6+)
**Objetivo:** Preparar para miles de usuarios

- [ ] Migrar a Kubernetes
- [ ] Load balancing
- [ ] CDN para assets
- [ ] Redis caching
- [ ] Elasticsearch para b√∫squedas
- [ ] Monitoreo con Prometheus/Grafana
- [ ] Auto-scaling

**Entregable:** Infraestructura escalable

---

## üìà M√©tricas de √âxito

### T√©cnicas (PoC)
- ‚úÖ Consumo bater√≠a ‚â§ 10% en 8 horas
- ‚úÖ Tasa de captura ‚â• 95%
- ‚úÖ API latency < 500ms
- ‚úÖ Precisi√≥n GPS ‚â§ 30m promedio
- ‚úÖ Uptime ‚â• 99%
- ‚úÖ 0 crashes en 24h continuas

### Producto (Post-PoC)
- üìä Usuarios activos diarios (DAU)
- üìä Retenci√≥n D1, D7, D30
- üìä Tiempo promedio de sesi√≥n
- üìä Frecuencia de uso (d√≠as/semana)
- üìä Net Promoter Score (NPS)

### Negocio (Futuro)
- üí∞ Tasa de conversi√≥n free ‚Üí premium
- üí∞ Costo de adquisici√≥n (CAC)
- üí∞ Lifetime value (LTV)
- üí∞ Churn rate

---

## üîí Consideraciones de Seguridad y Privacidad

### Seguridad T√©cnica

#### API:
- ‚úÖ HTTPS obligatorio en producci√≥n
- ‚úÖ Validaci√≥n de tokens JWT (Firebase)
- ‚úÖ Rate limiting (100 req/min por usuario)
- ‚úÖ Input validation y sanitization
- ‚úÖ SQL injection prevention (prepared statements)
- ‚úÖ CORS configurado correctamente

#### Base de Datos:
- ‚úÖ Credenciales en variables de entorno
- ‚úÖ Backup autom√°tico diario
- ‚úÖ Encriptaci√≥n en reposo (PostgreSQL)
- ‚úÖ Acceso restringido por firewall

#### App:
- ‚úÖ Almacenamiento seguro de tokens
- ‚úÖ HTTPS pinning (opcional)
- ‚úÖ Obfuscaci√≥n de c√≥digo (release)

### Privacidad del Usuario

#### Transparencia:
- ‚úÖ Notificaci√≥n visible cuando tracking activo
- ‚úÖ Explicar claramente qu√© datos se capturan
- ‚úÖ Pol√≠tica de privacidad accesible
- ‚úÖ T√©rminos y condiciones

#### Control del Usuario:
- ‚úÖ Pausar/reanudar tracking f√°cilmente
- ‚úÖ Eliminar historial (por d√≠a, por rango, todo)
- ‚úÖ Exportar sus propios datos
- ‚úÖ Eliminar cuenta completa

#### GDPR Compliance (si aplica):
- ‚úÖ Derecho al olvido
- ‚úÖ Derecho a la portabilidad
- ‚úÖ Consentimiento expl√≠cito
- ‚úÖ Minimizaci√≥n de datos
- ‚úÖ Retenci√≥n limitada (1 a√±o por defecto)

### Recomendaciones Legales

**IMPORTANTE:** Consultar con abogado antes de lanzar. Temas a revisar:
- Pol√≠tica de privacidad
- T√©rminos de servicio
- Compliance con leyes locales
- Responsabilidad por uso indebido
- Protecci√≥n de datos de menores

---

## üêõ Troubleshooting

### Problemas Comunes

#### 1. GPS no obtiene ubicaci√≥n
**S√≠ntomas:** `getCurrentLocation()` retorna null o timeout

**Soluciones:**
```dart
// Verificar permisos
await Geolocator.checkPermission()

// Verificar si GPS est√° activado
bool serviceEnabled = await Geolocator.isLocationServiceEnabled();

// Aumentar timeout
await Geolocator.getCurrentPosition(
  timeLimit: Duration(seconds: 30)
);
```

#### 2. Foreground service se detiene
**S√≠ntomas:** Tracking se para solo

**Soluciones:**
- Verificar bater√≠a no en modo ahorro extremo
- Verificar app no en "Doze mode"
- Agregar a whitelist de bater√≠a
- Usar `allowWakeLock: true`

#### 3. API retorna 401 Unauthorized
**S√≠ntomas:** Requests fallan con 401

**Soluciones:**
```dart
// Verificar token no expir√≥
String? token = await FirebaseAuth.instance.currentUser?.getIdToken(true);

// Verificar formato header
'Authorization': 'Bearer $token'  // con "Bearer "
```

#### 4. Queries PostGIS lentas
**S√≠ntomas:** Endpoints tardan >2 segundos

**Soluciones:**
```sql
-- Verificar √≠ndices existen
\d locations

-- Recrear √≠ndice espacial
REINDEX INDEX idx_locations_geom;

-- Analyze tabla
ANALYZE locations;

-- Ver query plan
EXPLAIN ANALYZE SELECT ...;
```

#### 5. Consumo alto de bater√≠a
**S√≠ntomas:** >15% en 8 horas

**Soluciones:**
- Cambiar a `LocationAccuracy.low` o `balanced`
- Aumentar `distanceFilter` a 100-200m
- Aumentar intervalo a 10 minutos
- Verificar no hay location listeners duplicados

---

## üìû Contacto y Soporte

### Durante Desarrollo (PoC)
- **Persona 1 (Backend):** [email/slack]
- **Persona 2 (Frontend):** [email/slack]
- **Reuniones diarias:** [horario]
- **Repositorio:** [GitHub URL]
- **Documentaci√≥n:** [Confluence/Notion URL]

### Post-PoC
- **Email soporte:** support@tudominio.com
- **Documentaci√≥n API:** https://api.tudominio.com/docs
- **Status page:** https://status.tudominio.com
- **GitHub Issues:** [repo URL]/issues

---

## üìö Referencias y Recursos

### Documentaci√≥n Oficial
- **Flutter:** https://docs.flutter.dev
- **Spring Boot:** https://docs.spring.io/spring-boot/
- **PostgreSQL:** https://www.postgresql.org/docs/
- **PostGIS:** https://postgis.net/documentation/
- **Firebase:** https://firebase.google.com/docs

### Librer√≠as Clave
- **geolocator:** https://pub.dev/packages/geolocator
- **flutter_map:** https://pub.dev/packages/flutter_map
- **Hibernate Spatial:** https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#spatial

### Tutoriales y Gu√≠as
- **PostGIS Tutorial:** https://postgis.net/workshops/postgis-intro/
- **Flutter Background Location:** https://medium.com/flutter-community/executing-dart-in-the-background-with-flutter-plugins-and-geofencing-2b3e40a1a124
- **OSRM Setup:** https://github.com/Project-OSRM/osrm-backend/wiki

### Herramientas
- **PostGIS Viewer:** QGIS (https://qgis.org/)
- **API Testing:** Postman (https://www.postman.com/)
- **DB Admin:** pgAdmin (https://www.pgadmin.org/)
- **Monitoring:** Grafana (https://grafana.com/)

---

## ‚úÖ Checklist Final

### Antes de Desplegar a Producci√≥n

#### Seguridad:
- [ ] HTTPS configurado con certificado v√°lido
- [ ] Credenciales en variables de entorno (no en c√≥digo)
- [ ] Rate limiting activado
- [ ] Firebase rules configuradas
- [ ] SQL injection protection verificado
- [ ] CORS configurado correctamente

#### Performance:
- [ ] √çndices de DB creados
- [ ] Connection pooling configurado
- [ ] Caching implementado donde aplica
- [ ] Queries optimizadas (< 100ms)
- [ ] Images/assets optimizados

#### Monitoreo:
- [ ] Logging configurado
- [ ] Error tracking (Sentry/similar)
- [ ] Uptime monitoring
- [ ] Alertas configuradas
- [ ] Backup autom√°tico funcionando

#### Legal:
- [ ] Pol√≠tica de privacidad publicada
- [ ] T√©rminos de servicio publicados
- [ ] Consentimiento de usuario implementado
- [ ] GDPR compliance verificado (si aplica)

#### Testing:
- [ ] Tests unitarios pasando
- [ ] Tests de integraci√≥n pasando
- [ ] Probado en m√∫ltiples dispositivos
- [ ] Probado en diferentes condiciones de red
- [ ] Load testing realizado

#### Documentaci√≥n:
- [ ] README actualizado
- [ ] API documentation completa
- [ ] Runbook para operaciones
- [ ] Gu√≠a de troubleshooting
- [ ] Changelog actualizado

---

## üì± Frontend (Mobile) - Estado actual y comandos

### Estructura implementada (Flutter)

```
lib/
‚îú‚îÄ‚îÄ main.dart                            # Arranque de app, `LocationTrackerApp`
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ constants.dart                   # `Constants.apiBaseUrl`
‚îú‚îÄ‚îÄ firebase_options.dart                # Config firebase (generado por flutterfire)
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ location_point.dart              # Modelo `LocationPoint`
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ api_service.dart                 # Cliente HTTP (registro usuario + ubicaciones)
‚îÇ   ‚îú‚îÄ‚îÄ auth_service.dart                # Wrapper FirebaseAuth (login/register/logout)
‚îÇ   ‚îú‚îÄ‚îÄ identity_service.dart            # Exposici√≥n del usuario autenticado via Firebase
‚îÇ   ‚îú‚îÄ‚îÄ location_service.dart            # Servicio ubicaci√≥n (Geolocator + stream)
‚îÇ   ‚îú‚îÄ‚îÄ foreground_service_manager.dart  # Inicializa flutter_foreground_task (notificaci√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ location_sync_manager.dart       # Maneja reintentos/offline queue
‚îÇ   ‚îî‚îÄ‚îÄ pending_location_store.dart      # Persistencia de pendientes (SharedPreferences)
‚îî‚îÄ‚îÄ screens/
    ‚îú‚îÄ‚îÄ login_screen.dart                # Formulario de login/registro (Firebase Auth)
    ‚îî‚îÄ‚îÄ map_screen.dart                  # Pantalla de mapa (flutter_map)
```

- **`lib/main.dart`**: Inicializa Firebase, escucha el estado de autenticaci√≥n y redirige a `LoginScreen` o `MapScreen`.
- **`lib/screens/map_screen.dart`**: Mapa con `flutter_map`, visualiza la ruta con `PolylineLayer` y marcadores de inicio/fin. Bot√≥n principal para iniciar/detener tracking, atajo para recenter y bot√≥n de historial (consulta `/api/locations/history`) que pinta la ruta guardada, muestra distancia total y despliega un modal con la lista detallada de puntos (lat/lon/hora). Incluye men√∫ para cerrar sesi√≥n.
- **`lib/screens/login_screen.dart`**: UI de inicio de sesi√≥n y registro usando Firebase Auth (email/contrase√±a).
- **`lib/services/auth_service.dart`**: Encapsula Firebase Auth (signIn/signUp/signOut) y expone `authStateChanges`.
- **`lib/services/identity_service.dart`**: Expone el usuario autenticado (`uid`, `email`, `getIdToken`) usando Firebase Auth.
- **`lib/services/location_service.dart`**: Encapsula permisos y stream de posiciones con `Geolocator`, mappea m√©tricas (accuracy, speed, heading). Arranca/detiene el servicio foreground y expone `start()`, `stop()`, `getCurrentOnce()` y `stream` de `LocationPoint`.
- **`lib/services/foreground_service_manager.dart`**: Configura `flutter_foreground_task`, mantiene notificaci√≥n persistente y muestra bater√≠a usando `battery_plus` para evitar que Android mate el proceso en background.
- **`lib/services/identity_service.dart`**: Genera/persiste un UID (UUID) y email sint√©tico para registrar el usuario en el backend.
- **`lib/services/api_service.dart`**: Env√≠a `POST /api/users`, `POST /api/locations` y expone `GET /api/locations/history`/`/distance`.
- **`lib/models/location_point.dart`**: Incluye lat/lon/timestamp y campos opcionales (`accuracy`, `altitude`, `speed`, `heading`), con `toJson`.
- **`lib/config/constants.dart`**: Calcula `apiBaseUrl` din√°mico (`10.0.2.2` en Android, `localhost` en otras plataformas).
- **`lib/services/location_sync_manager.dart` + `pending_location_store.dart`**: Guardan ubicaciones pendientes en `SharedPreferences` y las reintentan cuando el backend vuelve a estar disponible.

> **Autenticaci√≥n:** la app presenta un flujo de login/registro con Firebase Auth (email/contrase√±a). Tras autenticarse, se usan el `firebaseUid` real y el ID token para registrar al usuario y enviar las ubicaciones al backend.

### Dependencias m√≥viles (pubspec.yaml)

Referencia directa desde `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.8
  geolocator: ^11.0.0
  flutter_map: ^6.1.0
  latlong2: ^0.9.0
  firebase_core: ^2.24.2
  firebase_auth: ^4.15.3
  flutter_foreground_task: ^6.1.1
  battery_plus: ^5.0.2
  http: ^1.1.2
  shared_preferences: ^2.3.2
```

Nota: Aunque `firebase_*`, `flutter_foreground_task`, `battery_plus` y `http` est√°n listadas para el roadmap, la implementaci√≥n actual utiliza principalmente `geolocator`, `flutter_map` y `latlong2`.

### Comandos usados para ejecutar el frontend

- **Instalaci√≥n y verificaci√≥n**
  - `flutter doctor`  
  - `flutter pub get`
  - `flutterfire configure` (genera `lib/firebase_options.dart` y archivos nativos)
  - Copiar `android/app/google-services.json` y `ios/Runner/GoogleService-Info.plist` provistos por Firebase

> El repositorio contiene un `lib/firebase_options.dart` de ejemplo que lanza una excepci√≥n. Reempl√°zalo por el archivo generado autom√°ticamente tras ejecutar `flutterfire configure`.

- **Dispositivos y emuladores**
  - `flutter devices`  
  - `flutter emulators`  
  - `emulator -avd flutter_emulator &`  
  - `adb wait-for-device`

- **Ejecuci√≥n y desarrollo**
  - `flutter run`  
  - En sesi√≥n interactiva: usar `r` (hot reload) y `R` (hot restart)

- **Builds**
  - `flutter build apk --release`  
  - Salida: `build/app/outputs/flutter-apk/app-release.apk`

### Notas de permisos Android (recordatorio)

Para tracking en background y mapas, recuerda configurar permisos en `android/app/src/main/AndroidManifest.xml` (ubicaci√≥n precisa, foreground service, internet, etc.). La gu√≠a detallada ya est√° en este documento en la secci√≥n de setup de Android.

- Se activa un servicio `flutter_foreground_task` cuando el tracking est√° en marcha para evitar que el sistema finalice la app en segundo plano. La notificaci√≥n muestra el nivel de bater√≠a (requerido por pol√≠ticas Android 13+).

---

## üéâ Conclusi√≥n

Este documento representa el blueprint completo para tu proyecto de tracking de ubicaci√≥n. Con este plan, tienes:

‚úÖ Stack tecnol√≥gico definido y justificado
‚úÖ Arquitectura clara y escalable
‚úÖ Plan de desarrollo semana a semana
‚úÖ C√≥digo de referencia para empezar
‚úÖ Gu√≠as de setup y despliegue
‚úÖ Roadmap a futuro

**Siguiente paso:** Comenzar con el setup del servidor (Persona 1) y proyecto Flutter (Persona 2).

¬°Mucho √©xito con el proyecto! üöÄ

---

**Versi√≥n:** 1.0
**Fecha:** Octubre 2025
**Autores:** [Tu equipo]
**Licencia:** [A definir]

---

## ü§ñ Configuraci√≥n de Emulador Android desde Terminal

Esta secci√≥n documenta c√≥mo crear y ejecutar un emulador Android usando √∫nicamente la l√≠nea de comandos, √∫til cuando no tienes Android Studio instalado o prefieres automatizar el proceso.

### 1. Verificar las herramientas de Android SDK disponibles

Primero, aseg√∫rate de que las herramientas de l√≠nea de comandos del Android SDK est√©n correctamente instaladas y configuradas:

```bash
# Configurar variables de entorno
export ANDROID_HOME=~/Android/Sdk
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools:$ANDROID_HOME/emulator

# Verificar que sdkmanager est√° disponible
which sdkmanager
# Salida esperada: /home/usuario/Android/Sdk/cmdline-tools/latest/bin/sdkmanager

# Verificar que avdmanager est√° disponible
which avdmanager
# Salida esperada: /home/usuario/Android/Sdk/cmdline-tools/latest/bin/avdmanager
```

### 2. Listar im√°genes del sistema disponibles

Puedes verificar qu√© im√°genes del sistema (system images) ya tienes instaladas:

```bash
# Ver im√°genes instaladas localmente
ls ~/Android/Sdk/system-images/

# Ejemplo de salida:
# android-33  android-34  android-35  android-36  android-36.1

# Ver detalles de una imagen espec√≠fica
ls ~/Android/Sdk/system-images/android-34/
# Salida: google_apis_playstore

# Verificar que la imagen est√° completa
find ~/Android/Sdk/system-images/android-34 -name "system.img"
# Si encuentra archivos .img, la imagen est√° lista para usar
```

**Nota:** Si necesitas descargar nuevas im√°genes del sistema, usa:

```bash
# Listar todas las im√°genes disponibles para descargar
sdkmanager --list | grep "system-images"

# Instalar una imagen espec√≠fica (ejemplo: Android 34 con Play Store)
sdkmanager "system-images;android-34;google_apis_playstore;x86_64"
```

### 3. Descargar una imagen del sistema Android

Las im√°genes del sistema ya instaladas en tu m√°quina incluyen:
- **Android 34** (API 34) - Recomendado para desarrollo
- **Android 35, 36, 36.1** - Versiones m√°s recientes

Si ya tienes im√°genes instaladas (como en el ejemplo anterior), puedes saltarte este paso. De lo contrario:

```bash
# Ejemplo: Instalar Android 34 con Google Play Store
sdkmanager "system-images;android-34;google_apis_playstore;x86_64"

# Aceptar licencias si es necesario
sdkmanager --licenses
```

### 4. Crear el emulador AVD (Android Virtual Device)

Usa `avdmanager` para crear un nuevo dispositivo virtual:

```bash
# Crear emulador con Android 34, tipo Pixel 6
echo "no" | ~/Android/Sdk/cmdline-tools/latest/bin/avdmanager create avd \
  -n flutter_emulator \
  -k "system-images;android-34;google_apis_playstore;x86_64" \
  -d "pixel_6"

# Salida esperada:
# Loading local repository...
# Auto-selecting single ABI x86_64
# AVD 'flutter_emulator' created successfully
```

**Par√°metros explicados:**
- `-n flutter_emulator` - Nombre del emulador
- `-k "system-images;..."` - Path de la imagen del sistema a usar
- `-d "pixel_6"` - Tipo de dispositivo (tambi√©n puede ser: pixel_5, pixel_7, nexus_5x, etc.)

**Verificar que se cre√≥:**

```bash
# Listar emuladores disponibles
~/Android/Sdk/cmdline-tools/latest/bin/avdmanager list avd

# O con Flutter
flutter emulators
# Salida esperada: flutter_emulator
```

### 5. Iniciar el emulador

Existen dos formas de iniciar el emulador:

#### Opci√≥n A: Modo interactivo (con ventana)

```bash
# Iniciar el emulador
~/Android/Sdk/emulator/emulator -avd flutter_emulator

# Opciones √∫tiles:
# -no-snapshot-save    No guarda el estado al cerrar (m√°s r√°pido)
# -no-audio            Desactiva el audio (reduce recursos)
# -gpu host            Usa GPU del host (mejor rendimiento)
```

#### Opci√≥n B: Modo background (sin bloquear terminal)

```bash
# Iniciar en segundo plano
~/Android/Sdk/emulator/emulator -avd flutter_emulator -no-snapshot-save -no-audio > /tmp/emulator.log 2>&1 &

# Esperar a que arranque (puede tomar 1-2 minutos)
sleep 30

# Verificar estado
~/Android/Sdk/platform-tools/adb devices

# Salida cuando est√° listo:
# List of devices attached
# emulator-5554    device    ‚Üê "device" significa listo para usar
```

**Estados del emulador:**
- `offline` - Iniciando, a√∫n no est√° listo
- `device` - Listo para recibir comandos
- `unauthorized` - Requiere autorizaci√≥n en pantalla

### 6. Ejecutar la aplicaci√≥n Flutter en el emulador

Una vez que el emulador muestra estado `device`:

```bash
# Opci√≥n 1: Ejecutar en el emulador detectado autom√°ticamente
flutter run

# Opci√≥n 2: Especificar el emulador expl√≠citamente
flutter run -d emulator-5554

# Opci√≥n 3: Compilar e instalar APK directamente
flutter build apk
adb install build/app/outputs/flutter-apk/app-debug.apk
```

**Salida esperada durante la compilaci√≥n:**

```
Resolving dependencies...
Got dependencies!
Launching lib/main.dart on sdk gphone64 x86 64 in debug mode...
Running Gradle task 'assembleDebug'...                          360.2s
‚úì Built build/app/outputs/flutter-apk/app-debug.apk
Installing build/app/outputs/flutter-apk/app-debug.apk...        1.5s

Flutter run key commands:
r Hot reload.
R Hot restart.
d Detach.
q Quit.
```

### Comandos √∫tiles durante desarrollo

```bash
# Hot reload (aplicar cambios sin reiniciar)
# Presiona 'r' en la terminal donde corre Flutter

# Hot restart (reiniciar la app)
# Presiona 'R' en la terminal

# Ver logs en tiempo real
adb logcat | grep flutter

# Tomar screenshot del emulador
adb exec-out screencap -p > screenshot.png

# Simular ubicaci√≥n GPS (√∫til para testing)
adb emu geo fix -77.0428 -12.0464  # longitud latitud

# Limpiar datos de la app
adb shell pm clear com.example.flutter_application_1

# Desinstalar la app
adb uninstall com.example.flutter_application_1
```

### Troubleshooting com√∫n

#### Problema: "ANDROID_HOME not found"
```bash
# Soluci√≥n: Agregar a ~/.bashrc o ~/.zshrc
export ANDROID_HOME=~/Android/Sdk
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
export PATH=$PATH:$ANDROID_HOME/platform-tools
export PATH=$PATH:$ANDROID_HOME/emulator

# Recargar configuraci√≥n
source ~/.bashrc  # o source ~/.zshrc
```

#### Problema: El emulador no inicia o se queda "offline"
```bash
# Verificar que KVM est√° habilitado (Linux)
kvm-ok
# Si no est√° instalado: sudo apt install cpu-checker

# Dar permisos KVM
sudo usermod -aG kvm $USER
# Cerrar sesi√≥n y volver a entrar

# Reintentar con m√°s tiempo de espera
sleep 60 && adb devices
```

#### Problema: "No space left on device"
```bash
# Eliminar emuladores viejos
avdmanager delete avd -n nombre_viejo

# Limpiar cach√©s de Android SDK
rm -rf ~/.android/avd/*.avd/cache/*

# Ver uso de espacio
du -sh ~/.android/avd/*
```

#### Problema: Gradle build muy lento
```bash
# Agregar a android/gradle.properties
org.gradle.jvmargs=-Xmx4096m
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true

# Limpiar cach√© de Gradle
cd android && ./gradlew clean
```

### Recomendaciones finales

#### Para desarrollo diario

1. **Mant√©n el emulador corriendo** - No lo cierres entre sesiones de desarrollo, ahorra tiempo de inicio
2. **Usa hot reload** - Presiona `r` para ver cambios instant√°neamente sin recompilar
3. **Crea snapshots** - Guarda estados del emulador para inicio r√°pido:
   ```bash
   # Al cerrar el emulador, guarda estado
   emulator -avd flutter_emulator -snapshot-save my_snapshot

   # Restaurar snapshot al iniciar
   emulator -avd flutter_emulator -snapshot-load my_snapshot
   ```

#### Optimizaci√≥n de rendimiento

```bash
# Emulador m√°s r√°pido con configuraci√≥n optimizada
emulator -avd flutter_emulator \
  -no-snapshot-save \
  -no-audio \
  -gpu host \
  -memory 4096 \
  -cores 4 \
  -wipe-data  # Solo la primera vez
```

#### Para testing de ubicaci√≥n

```bash
# Script para simular movimiento (crear archivo simulate_route.sh)
#!/bin/bash
# Simula ruta Lima, Per√∫
coords=(
  "-77.0428 -12.0464"
  "-77.0435 -12.0470"
  "-77.0442 -12.0476"
  "-77.0449 -12.0482"
)

for coord in "${coords[@]}"; do
  adb emu geo fix $coord
  echo "Ubicaci√≥n establecida: $coord"
  sleep 300  # Esperar 5 minutos entre puntos
done
```

#### Automatizaci√≥n con script

Crea un archivo `start_dev.sh` para automatizar todo:

```bash
#!/bin/bash
# start_dev.sh - Inicia entorno de desarrollo completo

echo "üöÄ Iniciando entorno de desarrollo..."

# 1. Iniciar emulador en background
echo "üì± Iniciando emulador Android..."
~/Android/Sdk/emulator/emulator -avd flutter_emulator -no-snapshot-save -no-audio &
EMULATOR_PID=$!

# 2. Esperar a que est√© listo
echo "‚è≥ Esperando a que el emulador arranque..."
adb wait-for-device
sleep 10  # Espera adicional para que cargue completamente

# 3. Verificar estado
echo "‚úÖ Emulador listo:"
adb devices

# 4. Ejecutar Flutter
echo "üî• Ejecutando Flutter app..."
flutter run -d emulator-5554

# Cleanup al salir
trap "kill $EMULATOR_PID" EXIT
```

Hacer ejecutable:
```bash
chmod +x start_dev.sh
./start_dev.sh
```

#### Para producci√≥n / testing

```bash
# Compilar APK de release
flutter build apk --release

# APK estar√° en:
# build/app/outputs/flutter-apk/app-release.apk

# Instalar en dispositivo f√≠sico
adb install build/app/outputs/flutter-apk/app-release.apk

# O generar App Bundle para Play Store
flutter build appbundle --release
# Archivo en: build/app/outputs/bundle/release/app-release.aab
```

---

### Resumen de comandos esenciales

```bash
# Setup inicial (solo una vez)
export ANDROID_HOME=~/Android/Sdk
avdmanager create avd -n flutter_emulator -k "system-images;android-34;google_apis_playstore;x86_64" -d pixel_6

# Desarrollo diario
emulator -avd flutter_emulator &
adb wait-for-device
flutter run

# Comandos √∫tiles
flutter devices              # Ver dispositivos disponibles
flutter emulators            # Ver emuladores disponibles
adb devices                  # Ver estado de dispositivos conectados
adb logcat | grep flutter    # Ver logs de Flutter
```

---

**¬°Con esto tienes todo listo para desarrollar tu app de tracking de ubicaci√≥n!** üéâ
